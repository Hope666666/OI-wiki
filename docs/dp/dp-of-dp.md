author: Hope666666

## 引入

本文将介绍 DP 套 DP 的思想，并通过两道例题展示它如何应用到具体问题中。

## 思想

所谓「DP 套 DP」，实际上指的是在动态规划的过程中，把一个子问题的求解过程（通常是一个 DP）抽象成一个状态机（DFA），然后在这个自动机的基础上再设计一层新的 DP 的方法。

这种技巧主要应用于一类 **序列计数**、**概率** 或 **期望** 问题。通常，这类问题具有如下结构：

-   给定一个字符集 $\Sigma$ 上、长度为 $n$ 的序列集合 $A$。根据字符集不同，序列可以是二进制串、数字串、状态序列等。
-   对于每一个具体的序列 $s\in \Sigma^n$，我们有办法用动态规划来判断它是否合法（即 $s\in A$），计算它的权值或求出相关值。
-   最终，我们希望统计集合 $A$ 中所有序列的总方案数、总权值、期望值等。

这时，枚举所有序列是不可行的。于是我们考虑将「判断一个序列是否合法」的过程（即内层 DP）抽象为一个 [确定有限状态自动机](../string/automaton.md)（DFA）。一般地，对于固定的序列 $s\in\Sigma^n$，内层 DP 的状态函数可以表示为 $g(i,x)$，即已经处理完序列 $s$ 的长度为 $i$ 的前缀，且其他状态分量为 $x$ 时某个量的取值。相应地，内层 DP 的状态转移方程为

$$
g(i,\cdot;s) = G(g(i-1,\cdot;s),s_i).
$$

也就是说，函数 $g(i,\cdot;s)$ 由之前的函数 $g(i-1,\cdot;s)$ 和当前的字符 $s_i$ 唯一确定。如果将函数 $g(i,\cdot)$ 看作是自动机的一个状态，那么，内层 DP 的状态转移方程就给出了自动机的一个转移。因此，内层 DP 对应的自动机的状态集合 $Q$ 就是所有可能的 $s\in\Sigma^n$ 和 $i=0,1,\cdots,n$ 对应的函数 $g(i,\cdot;s)$ 的集合，自动机的转移 $\delta:Q\times\Sigma\to Q$ 就对应着内层 DP 的状态转移方程中的 $G$，初始状态 $q_0$ 通常是显然的，而接受状态集合 $F$ 就对应着所有合法序列 $s\in A$。函数 $g(i,\cdot;s)$ 本身可能相当复杂，因此，在处理具体问题时，通常需要进行 [状态压缩](./state.md) 或结合 DFA 最小化的技巧来压缩状态空间。这也是 DP 套 DP 相较于暴力 DP 能够显著优化时空复杂度的主要原因。

将内层 DP 抽象为 DFA 后，就可以在这个 DFA 上设计一个新的 DP 用于求解原问题，即外层 DP。为方便表述，以计数问题为例。外层 DP 的状态函数定义为 $f(i,q)$，即处理到长度为 $i$ 的前缀时，到达 DFA 中状态 $q\in Q$ 的前缀的数目。它的状态转移方程为

$$
f(i,q) = \sum_{c\in\Sigma}\sum_{q'\in Q:\delta(q',c)=q} f(i-1,q').
$$

初始状态当然是 $f(0,q_0)$，而最终要求的答案通常可以根据 $\{f(n,q):q\in F\}$ 简单计算得到。外层 DP 实际上是 [DAG 上 DP](./dag.md) 的特殊情形。

## 例题

接下来的两个例题会详细说明 DP 套 DP 的一般做法。

### 例一

???+ note "[Hero meet devil](https://www.luogu.com.cn/problem/P10614)"
    给定一个字符集为 `ACGT` 的字符串 $S$。
    
    对于每个 $0\leq i \leq |S|$，求有多少个长度为 $m$，字符集 `ACGT` 的字符串 $T$，满足它与 $S$ 的最长公共子序列长度为 $i$。

我们首先会想到一个 DP：设 $f_{i,j}$ 表示对于长度为 $i$ 的 $T$，和 $S$ 的最长公共子序列为 $j$ 的方案数。但是这样无法转移，我们发现主要的问题是：我们不知道这个最长公共子序列对应的是哪些字符。

考虑朴素求最长公共子序列的过程：设 $g_{i,j}$ 表示考虑 $T$ 的前 $i$ 位和 $S$ 的前 $j$ 位，最长公共子序列的长度。我们发现，对于一个 $i$，只需要记录 $g_i$ 这个一维数组每一位的值，就能准确维护当前 $S$ 与 $T$ 前 $i$ 位最长公共子序列的状态。因为 $S$ 长度只有 $15$，我们发现这个思想是可行的。

于是重新设状态 $f_{i,x}$ 表示对于长度为 $i$ 的 $T$，与 $S$ 的 DP 数组（就是 $g_i$）状态为 $x$ 的方案数。这个 DP 看起来状态数很多，然而我们可以发现 $g_{i,j}-g_{i,j-1}\le 1$，于是维护 $g_i$ 的差分数组，状态数是 $2^{|S|}$ 的。

现在思考怎么转移。容易发现，如果我们知道了 $g_i$ 这个数组，也知道了 $T_{i+1}$，就能通过朴素 LCS 转移求出 $g_{i+1}$。于是朴素的 LCS 就成为了帮助 $f$ 转移的内层 DP。

于是我们枚举 $T_{i+1}$，计算出 $x$ 转移后的状态 $x'$，$f_{i+1,x'}$ 加上 $f_{i,x}$ 即可。最后，我们记录 $ans_i$ 为 LCS 长度为 $i$ 的答案，枚举每个状态 $S$，$ans_{\operatorname{popcount(S)}}$ 加上 $f_{m,S}$ 即可。

??? note "参考代码"
    ```cpp
    --8<-- "docs/dp/code/dp-of-dp/dp-of-dp_1.cpp"
    ```

### 例二

???+ note "[\[ZJOI2019\] 麻将](https://loj.ac/p/3042)"
    给你 $13$ 张麻将牌，问你期望再摸多少张牌可以满足存在一个胡的子集。

首先我们要知道一个显然的性质，即对于一副牌，我们仅需要考虑其每张牌的张数，而顺序是没有任何关系的。因此，对于一副牌，我们可以将其转化为一个长度为 $n$，每个位置上为 $0\sim 4$ 的序列，这样就方便操作了许多。

考虑如何判断是否胡牌，考虑建立一个 **胡牌自动机**。具体地，考虑如果我们能得出一个判断一副牌是否能胡的 DP，然后把每个状态看作自动机的点，DP 转移看作自动机的边，则一个自动机就建成了。

设 $f_{0/1,i,j,k}$ 表示处理完前 $i$ 种牌，还剩 $j$ 组 $(i−1,i)$ 以及 $k$ 张 $i$，且存在/不存在 **对子** 时最多的 **面子** 数。
组合牌面可以使得 $0\leq j,k \leq 2$。于是可以对状态建立一个 $3\times 3$ 的矩阵存 $f_{0/1,i}$ 的全部答案。

假设加入了 $0\leq x\leq 4$ 张牌，则有如下 $3$ 种转移：

-   将 $f_{0,i-1}$ 加 $x$ 张牌转移到 $f_{0,i}$。
-   将 $f_{1,i-1}$ 加 $x$ 张牌转移到 $f_{1,i}$。
-   若 $x>1$，将 $f_{0,i-1}$ 加 $x-2$ 张牌转移到 $f_{1,i}$。

使用 BFS 思想一步一步拓展节点，最终在胡牌节点停止，即可建立自动机。注意拓展时关于 **七对** 的特判。一个优化是把全部胡牌节点压到一个节点上，使得空间时间更为优秀。

***

考虑如何胡牌自动机上 DP。

设 $g_i$ 表示摸了 $i$ 张牌后 **没有胡** 的方案数，则答案为：

$$
\frac{\sum_{i=1}^{4n-13}g_i i! (4n-13-i)!}{(4n-13)!} + 1.
$$

上式中分子的 $i!$ 和 $(4n−13−i)!$ 表示这 $i$ 张牌和剩下的 $4n−13−i$ 张牌放的顺序任意；由于是期望，所以需要除以总方案数 $(4n-13)!$；又因为 $g_i$ 表示摸了 $i$ 张牌后 **没有胡** 的方案数，所以需要加一。

设 $h_{i,j,k}$ 表示处理到第 $i$ 张牌，共摸了 $j$ 张牌，走到了胡牌自动机上的 $k$ 号节点的方案数。转移枚举摸牌数 $0\leq t\leq 4-a_i$，其中 $a_i$ 为初始 $13$ 张牌中用掉的 $i$ 的张数，于是就有转移：

$$
h_{i,j,k} \to h_{i+1,j+t,k'}.
$$

注意需要乘以 $4−a_i$ 张牌中选 $t$ 张牌的方案数，即 $\dbinom{4-a_i}{t}$。

??? note "参考代码"
    ```cpp
    --8<-- "docs/dp/code/dp-of-dp/dp-of-dp_2.cpp"
    ```

## 习题

-   [CF979E Kuro and Topological Parity](https://codeforces.com/problemset/problem/979/E)
-   [\[TJOI2018\] 游园会](https://loj.ac/p/2575)
-   [\[NOI2022\] 移除石子](https://loj.ac/p/3848)
